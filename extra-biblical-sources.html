<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Extra-Biblical Sources — Map (Hybrid Loader)</title>
<link rel="stylesheet" href="/israelite-research/styles.css"/>
<style>
  :root{--ink:#0b2340}
  html,body{height:100%;margin:0;background:#fff;color:var(--ink);font:14px/1.45 system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif}
  .container{max-width:1200px;margin:0 auto;padding:18px}
  .page-title{margin:.2rem 0 1rem;font-size:1.6rem;font-weight:800}
  .card{background:#fff;border:1px solid #e6ebf2;border-radius:14px;box-shadow:0 8px 24px rgba(0,0,0,.06);overflow:hidden}
  #chartdiv{width:100%;height:72vh;min-height:420px}
  .status{margin-top:10px;border:1px dashed #cbd5e1;border-radius:10px;padding:10px;color:#334155;background:#f8fafc}
  .status b{color:#0b2340}
  .status .bad{color:#b91c1c}
  .status .ok{color:#065f46}
</style>
</head>
<body>
<div id="site-header"></div>

<main class="container">
  <h1 class="page-title">Africa + Middle East Map</h1>
  <section class="card">
    <div id="chartdiv"></div>
  </section>

  <div class="status">
    <div><b>Loader:</b> <span id="loader-mode">linked</span></div>
    <div><b>Status:</b> <span id="map-status">Loading…</span></div>
    <div><b>Counts:</b> <span id="map-counts">—</span></div>
  </div>
</main>

<div id="site-footer"></div>

<script src="/israelite-research/js/shims.js" defer></script>
<script src="/israelite-research/js/include.js" defer></script>

<script src="https://cdn.amcharts.com/lib/5/index.js"></script>
<script src="https://cdn.amcharts.com/lib/5/map.js"></script>
<script src="https://cdn.amcharts.com/lib/5/geodata/region/world/africaLow.js"></script>
<script src="https://cdn.amcharts.com/lib/5/geodata/region/world/middleEastLow.js"></script>
<script src="https://cdn.amcharts.com/lib/5/themes/Animated.js"></script>

<script>
am5.ready(function() {
  const statusEl = document.getElementById("map-status");
  const countsEl = document.getElementById("map-counts");
  const modeEl   = document.getElementById("loader-mode");
  const setStatus = (t,c)=>{statusEl.textContent=t;statusEl.className=c||"";}
  const setCounts = (poly,lines,pts)=>{countsEl.textContent=`polygons:${poly}  lines:${lines}  points:${pts}`}

  function isSchema(obj){ return obj && typeof obj === "object" && !!obj.$schema; }
  function asArray(x){ return Array.isArray(x) ? x : (x ? [x] : []); }

  function extractCoords(obj){
    return obj.coordinates ?? obj.lonlats ?? obj.points ?? obj.lonlat ?? obj.coords ?? null;
  }
  function guessKind(obj, coords){
    const t=(obj.type||"").toLowerCase();
    if (t.includes("poly")) return "polygon";
    if (t.includes("line")) return "line";
    if (t.includes("point")) return "point";
    if (Array.isArray(coords) && Array.isArray(coords[0]) && Array.isArray(coords[0][0])) return "polygon";
    if (Array.isArray(coords) && Array.isArray(coords[0]) && !Array.isArray(coords[0][0]) && coords.length>=2) return "line";
    if (Array.isArray(coords) && coords.length===2 && typeof coords[0]==="number") return "point";
    if (Array.isArray(coords) && Array.isArray(coords[0]) && coords.length===1 && coords[0].length===2) return "point";
    return null;
  }
  async function loadJSON(path){
    const r=await fetch(path+"?v="+Date.now(),{cache:"no-store"});
    if(!r.ok) throw new Error(path+": "+r.status+" "+r.statusText);
    return r.json();
  }

  var root = am5.Root.new("chartdiv");
  root.setThemes([am5themes_Animated.new(root)]);
  var chart = root.container.children.push(am5map.MapChart.new(root, {
    panX:"rotateX", panY:"translateY",
    projection: am5map.geoNaturalEarth1()
  }));
  chart.chartContainer.set("background", am5.Rectangle.new(root,{fill:am5.color("#e0f2ff")}));

  const africa = chart.series.push(am5map.MapPolygonSeries.new(root,{geoJSON:am5geodata_region_world_africaLow}));
  const me     = chart.series.push(am5map.MapPolygonSeries.new(root,{geoJSON:am5geodata_region_world_middleEastLow}));
  const style = s=>s.mapPolygons.template.setAll({fill:am5.color("#f4ede1"),stroke:am5.color("#c4b79c"),strokeWidth:0.8});
  style(africa); style(me);

  function renderLayers(polyFeatures, lineFeatures, pointItems){
    const regions=chart.series.push(am5map.MapPolygonSeries.new(root,{}));
    regions.mapPolygons.template.setAll({tooltipText:"{name}\n{period}\n{blurb}",interactive:true,fillOpacity:0.55,strokeOpacity:1,strokeWidth:1});
    if (polyFeatures.length) regions.setAll({geoJSON:{type:"FeatureCollection",features:polyFeatures}});

    const routes=chart.series.push(am5map.MapLineSeries.new(root,{}));
    routes.mapLines.template.setAll({stroke:am5.color("#8b5e34"),strokeWidth:1.5,tooltipText:"{name}",strokeOpacity:0.8});
    if (lineFeatures.length) routes.setAll({geoJSON:{type:"FeatureCollection",features:lineFeatures}});

    const points=chart.series.push(am5map.MapPointSeries.new(root,{longitudeField:"longitude",latitudeField:"latitude"}));
    points.bullets.push(()=>am5.Bullet.new(root,{sprite:am5.Circle.new(root,{radius:4,fill:am5.color("#b91c1c"),tooltipText:"{title}\n{subtitle}"})}));
    if (pointItems.length) points.data.setAll(pointItems);

    regions.set("zIndex",15); routes.set("zIndex",20); points.set("zIndex",30);
    setCounts(polyFeatures.length, lineFeatures.length, pointItems.length);
  }

  async function loadLinked(){
    modeEl.textContent="linked";
    const [geomRaw, recsRaw] = await Promise.all([
      loadJSON("data/geometry.json"),
      loadJSON("data/ancient.json")
    ]);
    if (isSchema(geomRaw) || isSchema(recsRaw)) throw new Error("schema-detected");

    const geoms = Array.isArray(geomRaw) ? geomRaw
                 : (geomRaw && geomRaw.type==="FeatureCollection" ? geomRaw.features.map(f=>({id:(f.id||f.properties?.id||f.properties?.gid||""), type:f.geometry?.type||"Unknown", coordinates:f.geometry?.coordinates})) : null);
    const recs  = Array.isArray(recsRaw) ? recsRaw : (recsRaw && Array.isArray(recsRaw.records) ? recsRaw.records : null);
    if (!geoms || !recs) throw new Error("invalid-shape");

    const gById=new Map(geoms.map(g=>[String(g.id||g.geometry_id||g.gid||""),g]));
    const poly=[], lines=[], points=[];
    for (const r of recs){
      const gid=String(r.geometry_id||r.geometryId||r.geometryID||r.gid||"");
      if(!gid) continue;
      const g=gById.get(gid);
      if(!g) continue;
      const coords=extractCoords(g);
      const kind=guessKind(g,coords);
      const props={name:r.title||r.name||r.id||gid,period:r.period||"",blurb:r.blurb||"",kind:(r.type||"").toLowerCase()};
      if (kind==="polygon"){
        const rings=Array.isArray(coords[0][0])?coords:[coords];
        poly.push({type:"Feature",properties:props,geometry:{type:"Polygon",coordinates:rings}});
      } else if (kind==="line"){
        lines.push({type:"Feature",properties:props,geometry:{type:"LineString",coordinates:coords}});
      } else if (kind==="point"){
        const pt=Array.isArray(coords[0])?coords[0]:coords;
        points.push({longitude:pt[0],latitude:pt[1],title:props.name,subtitle:props.period||props.kind||""});
      }
    }
    renderLayers(poly,lines,points);
    setStatus("Linked files loaded","ok");
  }

  async function loadDynamic(){
    modeEl.textContent="dynamic";
    let indexData=null, indexUsed=null;
    try{ indexData=await loadJSON("data/ancient.index.json"); indexUsed="data/ancient.index.json"; }
    catch(e){
      try{
        const maybe=await loadJSON("data/ancient.json");
        if (Array.isArray(maybe)) { indexData=maybe; indexUsed="data/ancient.json"; }
        else if (!maybe.$schema && Array.isArray(maybe.records)) { indexData=maybe.records; indexUsed="data/ancient.json records[]"; }
      }catch(e2){}
    }
    if(!indexData || !indexData.length){ setStatus("No dynamic index found","bad"); return; }

    const poly=[], lines=[], points=[];
    for (const rec of indexData){
      const gid=String(rec.geometry_id||rec.geometryId||rec.geometryID||rec.gid||"");
      if(!gid) continue;
      const base="data/geometry/"+gid;
      const candidates=[
        base+".geometry.geojson",
        base+".simplified.geojson",
        base+".lonlats.json",
        base+".simplified_lonlats.json",
        "data/"+gid+".geojson",
        "data/"+gid+".json"
      ];
      let found=null, json=null;
      for (const u of candidates){
        try{ json=await loadJSON(u); found=u; break; }catch(e){}
      }
      if(!json) continue;

      const g = (json && json.type==="Feature") ? json.geometry : (json && json.type==="FeatureCollection" && Array.isArray(json.features) && json.features[0] ? json.features[0].geometry : json);
      const coords = g.coordinates ?? json.lonlats ?? json.points ?? json.lonlat ?? json.coords ?? null;
      const kind = guessKind(g, coords);
      const props={name:rec.title||rec.name||rec.id||gid,period:rec.period||"",blurb:rec.blurb||"",kind:(rec.type||"").toLowerCase()};
      if (kind==="polygon"){
        const rings=Array.isArray(coords[0][0])?coords:[coords];
        poly.push({type:"Feature",properties:props,geometry:{type:"Polygon",coordinates:rings}});
      } else if (kind==="line"){
        lines.push({type:"Feature",properties:props,geometry:{type:"LineString",coordinates:coords}});
      } else if (kind==="point"){
        const pt=Array.isArray(coords[0])?coords[0]:coords;
        points.push({longitude:pt[0],latitude:pt[1],title:props.name,subtitle:props.period||props.kind||""});
      }
    }
    renderLayers(poly,lines,points);
    setStatus("Dynamic per-ID geometry loaded","ok");
  }

  (async ()=>{
    try{
      await loadLinked();
    }catch(e){
      await loadDynamic();
    }
  })();

  var zoom=chart.set("zoomControl",am5map.ZoomControl.new(root,{}));
  zoom.homeButton.set("visible",true);
  zoom.homeButton.events.on("click",()=>chart.goHome());
});
</script>
</body>
</html>
