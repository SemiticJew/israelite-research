<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Extra-Biblical Sources — Map (Linked JSON)</title>
<link rel="stylesheet" href="/israelite-research/styles.css"/>
<style>
  :root{--ink:#0b2340}
  html,body{height:100%;margin:0;background:#fff;color:var(--ink);font:14px/1.45 system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif}
  .container{max-width:1200px;margin:0 auto;padding:18px}
  .page-title{margin:.2rem 0 1rem;font-size:1.6rem;font-weight:800}
  .card{background:#fff;border:1px solid #e6ebf2;border-radius:14px;box-shadow:0 8px 24px rgba(0,0,0,.06);overflow:hidden}
  #chartdiv{width:100%;height:72vh;min-height:420px}
  .status{margin-top:10px;border:1px dashed #cbd5e1;border-radius:10px;padding:10px;color:#334155;background:#f8fafc}
  .status b{color:#0b2340}
  .status .bad{color:#b91c1c}
  .status .ok{color:#065f46}
</style>
</head>
<body>
<div id="site-header"></div>

<main class="container">
  <h1 class="page-title">Africa + Middle East Map</h1>
  <section class="card">
    <div id="chartdiv"></div>
  </section>

  <div class="status">
    <div><b>Source:</b> ancient.json + geometry.json</div>
    <div><b>Status:</b> <span id="map-status">Loading…</span></div>
  </div>
</main>

<div id="site-footer"></div>

<script src="/israelite-research/js/shims.js" defer></script>
<script src="/israelite-research/js/include.js" defer></script>

<script src="https://cdn.amcharts.com/lib/5/index.js"></script>
<script src="https://cdn.amcharts.com/lib/5/map.js"></script>
<script src="https://cdn.amcharts.com/lib/5/geodata/region/world/africaLow.js"></script>
<script src="https://cdn.amcharts.com/lib/5/geodata/region/world/middleEastLow.js"></script>
<script src="https://cdn.amcharts.com/lib/5/themes/Animated.js"></script>

<script>
am5.ready(async function() {
  const statusEl = document.getElementById("map-status");
  const setStatus = (t,c)=>{statusEl.textContent=t;statusEl.className=c||"";}

  function isSchema(obj){ return obj && typeof obj === "object" && !!obj.$schema; }

  function normalizeRecords(raw){
    if (Array.isArray(raw)) return raw;
    if (raw && Array.isArray(raw.records)) return raw.records;
    return null;
  }

  function normalizeGeoms(raw){
    if (Array.isArray(raw)) return raw; // already list of {id,type,coords...}
    // GeoJSON FeatureCollection -> array of light objects
    if (raw && raw.type === "FeatureCollection" && Array.isArray(raw.features)) {
      return raw.features.map(f=>{
        const id = f.id || f.properties?.id || f.properties?.geometry_id || f.properties?.gid;
        const g  = f.geometry || {};
        return {
          id: String(id || ""),
          type: g.type || "Unknown",
          coordinates: g.coordinates
        };
      });
    }
    if (raw && Array.isArray(raw.geometries)) return raw.geometries;
    return null;
  }

  function extractCoords(obj){
    // Accept lonlat|lonlats|points|coordinates
    const coords = obj.lonlat || obj.lonlats || obj.points || obj.coordinates || obj.coords || null;
    return coords;
  }

  function guessKind(obj, coords){
    const t = (obj.type || "").toLowerCase();
    if (t.includes("poly")) return "polygon";
    if (t.includes("line")) return "line";
    if (t.includes("point")) return "point";
    // derive from coords shape
    if (Array.isArray(coords) && Array.isArray(coords[0]) && Array.isArray(coords[0][0])) return "polygon";
    if (Array.isArray(coords) && Array.isArray(coords[0]) && !Array.isArray(coords[0][0]) && coords.length >= 2) return "line";
    if (Array.isArray(coords) && coords.length === 2 && typeof coords[0] === "number") return "point";
    if (Array.isArray(coords) && Array.isArray(coords[0]) && coords.length === 1 && coords[0].length === 2) return "point";
    return null;
  }

  async function loadJSON(path){
    const r = await fetch(path + "?v=" + Date.now(), { cache:"no-store" });
    if (!r.ok) throw new Error(path + ": " + r.status + " " + r.statusText);
    return r.json();
  }

  var root = am5.Root.new("chartdiv");
  root.setThemes([am5themes_Animated.new(root)]);
  var chart = root.container.children.push(am5map.MapChart.new(root, {
    panX: "rotateX", panY: "translateY",
    projection: am5map.geoNaturalEarth1()
  }));
  chart.chartContainer.set("background", am5.Rectangle.new(root,{fill:am5.color("#e0f2ff")}));

  const africa = chart.series.push(am5map.MapPolygonSeries.new(root,{geoJSON:am5geodata_region_world_africaLow}));
  const me     = chart.series.push(am5map.MapPolygonSeries.new(root,{geoJSON:am5geodata_region_world_middleEastLow}));
  const style = s=>s.mapPolygons.template.setAll({fill:am5.color("#f4ede1"),stroke:am5.color("#c4b79c"),strokeWidth:0.8});
  style(africa); style(me);

  try {
    const [geomRaw, recsRaw] = await Promise.all([
      loadJSON("data/geometry.json"),
      loadJSON("data/ancient.json")
    ]);

    if (isSchema(geomRaw) || isSchema(recsRaw)) {
      setStatus("One or both files look like JSON Schema (validators), not data arrays.", "bad");
      return;
    }

    const geoms = normalizeGeoms(geomRaw);
    const recs  = normalizeRecords(recsRaw);

    if (!geoms || !recs) {
      setStatus("Invalid data shape. Expect arrays or FeatureCollection for geometry, and array/records[] for ancient.", "bad");
      console.warn("geometry.json shape:", geomRaw);
      console.warn("ancient.json shape:", recsRaw);
      return;
    }

    const gById = new Map(geoms.map(g => [String(g.id || g.geometry_id || g.gid || ""), g]));
    const poly=[], lines=[], points=[];

    for (const r of recs) {
      const gid = String(r.geometry_id || r.geometryId || r.geometryID || r.gid || "");
      if (!gid) continue;
      const g = gById.get(gid);
      if (!g) continue;

      const coords = extractCoords(g);
      const kind = guessKind(g, coords);
      const props = { name: r.title || r.name || r.id || gid, period: r.period || "", blurb: r.blurb || "", kind: (r.type||"").toLowerCase() };

      if (kind === "polygon") {
        const rings = Array.isArray(coords[0][0]) ? coords : [coords];
        poly.push({ type:"Feature", properties:props, geometry:{ type:"Polygon", coordinates:rings } });
      } else if (kind === "line") {
        lines.push({ type:"Feature", properties:props, geometry:{ type:"LineString", coordinates:coords } });
      } else if (kind === "point") {
        const pt = Array.isArray(coords[0]) ? coords[0] : coords;
        points.push({ longitude: pt[0], latitude: pt[1], title: props.name, subtitle: props.period || props.kind || "" });
      }
    }

    const regions=chart.series.push(am5map.MapPolygonSeries.new(root,{}));
    regions.mapPolygons.template.setAll({tooltipText:"{name}\n{period}\n{blurb}",interactive:true,fillOpacity:0.55,strokeOpacity:1,strokeWidth:1});
    regions.setAll({geoJSON:{type:"FeatureCollection",features:poly}});

    const routes=chart.series.push(am5map.MapLineSeries.new(root,{}));
    routes.mapLines.template.setAll({stroke:am5.color("#8b5e34"),strokeWidth:1.5,tooltipText:"{name}",strokeOpacity:0.8});
    routes.setAll({geoJSON:{type:"FeatureCollection",features:lines}});

    const pointsSeries=chart.series.push(am5map.MapPointSeries.new(root,{longitudeField:"longitude",latitudeField:"latitude"}));
    pointsSeries.bullets.push(()=>am5.Bullet.new(root,{sprite:am5.Circle.new(root,{radius:4,fill:am5.color("#b91c1c"),tooltipText:"{title}\n{subtitle}"})}));
    pointsSeries.data.setAll(points);

    setStatus(`Loaded ${poly.length} polygons, ${lines.length} lines, ${points.length} points`,"ok");
  } catch(e){
    console.error(e);
    setStatus(e.message || "Error loading data","bad");
  }

  var zoom=chart.set("zoomControl",am5map.ZoomControl.new(root,{}));
  zoom.homeButton.set("visible",true);
  zoom.homeButton.events.on("click",()=>chart.goHome());
});
</script>
</body>
</html>
