<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Extra-Biblical Sources — Map</title>
<link rel="stylesheet" href="/israelite-research/styles.css"/>
<style>
  :root{--ink:#0b2340}
  html,body{height:100%;margin:0;background:#fff;color:var(--ink);font:14px/1.45 system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif}
  .container{max-width:1200px;margin:0 auto;padding:18px}
  .page-title{margin:.2rem 0 1rem;font-size:1.6rem;font-weight:800}
  .card{background:#fff;border:1px solid #e6ebf2;border-radius:14px;box-shadow:0 8px 24px rgba(0,0,0,.06);overflow:hidden}
  #chartdiv{width:100%;height:72vh;min-height:420px}
  .status{margin-top:10px;border:1px dashed #cbd5e1;border-radius:10px;padding:10px;color:#334155;background:#f8fafc}
  .status b{color:#0b2340}
  .status .bad{color:#b91c1c}
  .status .ok{color:#065f46}
  .row{margin:2px 0}
</style>
</head>
<body>
<div id="site-header"></div>

<main class="container">
  <h1 class="page-title">Africa + Middle East Map</h1>
  <section class="card">
    <div id="chartdiv"></div>
  </section>

  <div class="status" id="status">
    <div class="row"><b>Geometry:</b> <span id="s-geom">pending…</span></div>
    <div class="row"><b>Ancient records:</b> <span id="s-recs">pending…</span></div>
    <div class="row"><b>Joined →</b>
      Polygons: <span id="s-polys">0</span>,
      Lines: <span id="s-lines">0</span>,
      Points: <span id="s-points">0</span>
    </div>
    <div class="row"><b>Notes:</b> <span id="s-notes">Looking good.</span></div>
  </div>
</main>

<div id="site-footer"></div>

<script src="/israelite-research/js/shims.js" defer></script>
<script src="/israelite-research/js/include.js" defer></script>

<script src="https://cdn.amcharts.com/lib/5/index.js"></script>
<script src="https://cdn.amcharts.com/lib/5/map.js"></script>
<script src="https://cdn.amcharts.com/lib/5/geodata/region/world/africaLow.js"></script>
<script src="https://cdn.amcharts.com/lib/5/geodata/region/world/middleEastLow.js"></script>
<script src="https://cdn.amcharts.com/lib/5/themes/Animated.js"></script>

<script>
am5.ready(function() {
  const $ = (id)=>document.getElementById(id);
  const set = (id, text, cls)=>{ const el=$(id); if(!el) return; el.textContent=text; if(cls){el.className=cls;} };

  // Map setup
  var root = am5.Root.new("chartdiv");
  root.setThemes([ am5themes_Animated.new(root) ]);

  var chart = root.container.children.push(am5map.MapChart.new(root, {
    panX: "rotateX",
    panY: "translateY",
    projection: am5map.geoNaturalEarth1()
  }));

  chart.chartContainer.set("background", am5.Rectangle.new(root, { fill: am5.color("#e0f2ff") }));

  function styleSeries(series) {
    series.mapPolygons.template.setAll({
      tooltipText: "{name}",
      toggleKey: "active",
      interactive: true,
      fill: am5.color("#f4ede1"),
      stroke: am5.color("#c4b79c"),
      strokeOpacity: 1,
      strokeWidth: 0.8
    });
    series.mapPolygons.template.states.create("hover",  { fill: am5.color("#fcd34d") });
    series.mapPolygons.template.states.create("active", { fill: am5.color("#b45309") });
  }

  var africaSeries = chart.series.push(am5map.MapPolygonSeries.new(root, {
    geoJSON: am5geodata_region_world_africaLow
  }));
  var meSeries = chart.series.push(am5map.MapPolygonSeries.new(root, {
    geoJSON: am5geodata_region_world_middleEastLow
  }));
  styleSeries(africaSeries);
  styleSeries(meSeries);

  // === Linked Ancient Layers with Diagnostics ===
  async function loadLinkedAncientLayers() {
    const gPath = "data/geometry.json";
    const aPath = "data/ancient.json";

    // fetch helpers (with status)
    async function getJSON(path, statusId) {
      try {
        const r = await fetch(path + "?v=" + Date.now(), { cache: "no-store" });
        if (!r.ok) { set(statusId, `${r.status} ${r.statusText}`, "bad"); return null; }
        const j = await r.json();
        set(statusId, Array.isArray(j) ? `OK (${j.length})` : (j ? "OK (object)" : "Empty"), "ok");
        return j;
      } catch (e) {
        set(statusId, e.message || "fetch error", "bad");
        return null;
      }
    }

    const geom = await getJSON(gPath, "s-geom");
    const recs = await getJSON(aPath, "s-recs");

    if (!geom || !recs) {
      set("s-notes", "Missing or unreadable JSON. Ensure files exist at data/geometry.json and data/ancient.json.", "bad");
      return;
    }

    // Normalize geometry → accept several shapes:
    // - { lonlat: [[lon,lat],... ] } (polygon/line)  OR  { points: [[lon,lat],...] }
    // - { coordinates: [[lon,lat],... ] } (line) OR [[[...]]] (polygon)
    // - Single point allowed: { lonlat: [[lon,lat]] } → point
    const gById = new Map(geom.map(g => [String(g.id), g]));

    const getCoords = (g) => {
      if (g.lonlat) return g.lonlat;
      if (g.points) return g.points;
      if (g.coordinates) return g.coordinates; // might be polygon or line
      return null;
    };

    const typeOf = (g) => (g.type || "").toLowerCase();

    const isPolygonLike = (g, coords) => {
      if (typeOf(g).startsWith("poly")) return true;
      // GeoJSON polygon detection: array-of-rings [[[...]]]
      return Array.isArray(coords) && Array.isArray(coords[0]) && Array.isArray(coords[0][0]);
    };

    const isLineLike = (g, coords) => {
      if (typeOf(g).includes("line")) return true;
      // GeoJSON LineString: [[...]]
      return Array.isArray(coords) && Array.isArray(coords[0]) && !Array.isArray(coords[0][0]) && coords.length >= 2;
    };

    const isPointLike = (coords) => Array.isArray(coords) && Array.isArray(coords[0]) && coords.length === 1;

    const polyFeatures = [];
    const lineFeatures = [];
    const pointItems  = [];
    let missingGeomLinks = 0;

    (recs || []).forEach(r => {
      const g = gById.get(String(r.geometry_id));
      if (!g) { missingGeomLinks++; return; }

      const coords = getCoords(g);
      if (!coords) return;

      const props = {
        name: r.title || r.name || r.id,
        kind: r.type || g.type || "feature",
        period: r.period || (g.properties && g.properties.period) || "",
        blurb: r.blurb || (g.properties && g.properties.blurb) || "",
        ...((g.properties) || {}),
        ...((r.properties) || {})
      };

      if (isPolygonLike(g, coords)) {
        // ensure polygon rings: wrap if needed
        const rings = Array.isArray(coords[0][0]) ? coords : [coords];
        polyFeatures.push({
          type: "Feature",
          properties: props,
          geometry: { type: "Polygon", coordinates: rings }
        });
      } else if (isLineLike(g, coords)) {
        lineFeatures.push({
          type: "Feature",
          properties: props,
          geometry: { type: "LineString", coordinates: coords }
        });
      } else if (isPointLike(coords)) {
        const pt = coords[0];
        pointItems.push({
          longitude: pt[0], latitude: pt[1],
          title: props.name,
          subtitle: props.period || props.kind || "",
          type: (props.kind || "site").toLowerCase()
        });
      } else {
        // Try last-ditch: a single lon/lat pair?
        if (Array.isArray(coords) && typeof coords[0] === "number" && typeof coords[1] === "number") {
          pointItems.push({
            longitude: coords[0], latitude: coords[1],
            title: props.name, subtitle: props.period || props.kind || "", type: (props.kind || "site").toLowerCase()
          });
        }
      }
    });

    // Show counts
    set("s-polys", String(polyFeatures.length));
    set("s-lines", String(lineFeatures.length));
    set("s-points", String(pointItems.length));
    if (missingGeomLinks > 0) {
      set("s-notes", `Warning: ${missingGeomLinks} record(s) had missing geometry_id matches.`, "bad");
    } else {
      set("s-notes", "Loaded linked layers.", "ok");
    }

    // Render layers
    const regionsSeries = chart.series.push(am5map.MapPolygonSeries.new(root, {}));
    regionsSeries.mapPolygons.template.setAll({
      tooltipText: "{name}\n{period}\n{blurb}",
      interactive: true,
      fillOpacity: 0.55,
      strokeOpacity: 1,
      strokeWidth: 1
    });
    const colorFor = (kind) => {
      const table = { kingdom:"#b56576", tribe:"#84a59d", province:"#6b9080", territory:"#bde0fe", region:"#ffd166", city:"#f9a8d4" };
      return am5.color(table[(kind||"").toLowerCase()] || "#cdb4db");
    };
    regionsSeries.mapPolygons.template.adapters.add("fill", (_fill, target) => {
      const d = target.dataItem?.dataContext?.properties; return colorFor(d?.kind);
    });
    regionsSeries.mapPolygons.template.adapters.add("stroke", () => am5.color("#333333"));
    regionsSeries.setAll({ geoJSON: { type: "FeatureCollection", features: polyFeatures } });

    const routesSeries = chart.series.push(am5map.MapLineSeries.new(root, {}));
    routesSeries.mapLines.template.setAll({
      stroke: am5.color("#8b5e34"),
      strokeWidth: 1.5,
      tooltipText: "{name}\n{period}",
      strokeOpacity: 0.8
    });
    routesSeries.setAll({ geoJSON: { type: "FeatureCollection", features: lineFeatures } });

    const sitesSeries = chart.series.push(am5map.MapPointSeries.new(root, {
      valueField: "value", longitudeField: "longitude", latitudeField: "latitude"
    }));
    const ICON = {
      site: "assets/icons/generic.svg",
      city: "assets/icons/covenant.svg",
      route: "assets/icons/exodus.svg",
      shrine: "assets/icons/miracle.svg"
    };
    sitesSeries.bullets.push(() => am5.Bullet.new(root, {
      sprite: am5.Picture.new(root, {
        width: 16, height: 16, centerX: am5.p50, centerY: am5.p50,
        src: ICON.site, tooltipText: "{title}\n{subtitle}"
      })
    }));
    sitesSeries.bulletsContainer.events.on("boundschanged", () => {
      sitesSeries.bulletsContainer.children.each(pic => {
        const d = pic.dataItem?.dataContext || {};
        pic.set("src", ICON[(d.type||"site")] || ICON.site);
      });
    });
    sitesSeries.data.setAll(pointItems);

    regionsSeries.set("zIndex", 15);
    routesSeries.set("zIndex", 20);
    sitesSeries.set("zIndex", 30);
  }

  loadLinkedAncientLayers().catch(err => {
    set("s-notes", (err && err.message) ? err.message : "Unknown error", "bad");
    console.error(err);
  });

  var zoomControl = chart.set("zoomControl", am5map.ZoomControl.new(root, {}));
  zoomControl.homeButton.set("visible", true);
  zoomControl.homeButton.events.on("click", function() { chart.goHome(); });
  chart.chartContainer.get("background").events.on("click", function() { chart.goHome(); });

  chart.appear(600, 100);
});
</script>
</body>
</html>
